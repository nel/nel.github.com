---
layout: default
---
<section id="about">
  <div class="hero-unit">
    <h1>Résultats:</h1>
    <p>
      Le <a href="https://gist.github.com/1583049">fichier de règles</a> qui a servi à déterminer le gagnant devait donner pour résultat : <strong>18769</strong>.
    </p>
    <p>
      <strong>9</strong> des candidats ont un programme qui retourne le bon résultat.</p>
    <p>
      <strong>Le gagnant</strong> <a href="https://twitter.com/adrienjarthon">@adrienjarthon</a>, désigné par tirage au sort le 10 janvier devant le public de <a href="http://www.meetup.com/parisrb/events/44098142/">Paris.rb</a> a gagné un <a href="https://twitter.com/#!/Dimelo/status/157105568992079874/photo/1">AR Drone</a> !</p>
    <p>
      Dimelo salue par ailleurs la <strong>prouesse artistique</strong> de <a href="https://twitter.com/brmichel">@brmichel</a> en lui offrant aussi un AR Drone pour sa solution extrêmement compacte (moins de 10 lignes).
    </p>
    <p>
      <strong>Bravo</strong> à Adrien et Michel ! <strong>Merci</strong> à tous les participants et bon hacking ! 
    </p>
    <p><a class="btn primary large" href="https://gist.github.com/1601550">Solution @adrianjarthon &raquo;</a> <a class="btn primary large" href="https://github.com/nono/Ruby-Christmas-Contest/blob/master/ruby-contest">Solution @brmichel &raquo;</a></p>
    <p>
    <a class="btn primary large" href="http://jobs.dimelo.com">Rejoignez Dimelo ! &raquo;</a></p>
  </div>
  <div class="row">
    <div class="span-one-third">
      <h3>Un défi en Ruby !</h3>
      <p>A partir des données d'un profil utilisateur <a href="http://github.com">github</a> on cherche à calculer un score basé sur ses caractéristiques.</p>
      <p>Le défi est de <strong>construire en ruby un moteur de règles de scoring</strong> qui s'applique aux données du profil github et en détermine un score. Le détail sur la syntaxe des règles et les données de profil sont accessibles dans la <a href="#contest">section suivante</a></p>
      <p>Nous vérifierons les programmes avec notre propre fichier de règles. Si vous avez des questions n'hésitez pas à les posez sur notre Twitter @dimelo.<p>
      <p>
        <a href="http://twitter.com/dimelo" class="twitter-follow-button">Follow @dimelo</a>
        <script src="http://platform.twitter.com/widgets.js" type="text/javascript"></script>
      </p>
    </div>
    <div class="span-one-third">
      <h3>Un <strong>AR Drone</strong> à gagner !</h3>
      <p>Vous en avez toujours voulu un, vous n'avez jamais osé l'acheter, vous pouvez le gagner : l'<a href="http://ardrone.parrot.com/parrot-ar-drone/fr/"><strong>AR Drone</strong></a></p>
      <iframe width="300" height="182" src="http://www.youtube.com/embed/EYvTJnWrH2Q" frameborder="0" allowfullscreen></iframe>
    </div>
    <div class="span-one-third" id="rules">
      <h3>Peu de règles !</h3>
      <p>Tout rubyiste peut participer ! Pour gagner, il faut :</p>
      <ul>
        <li>Fournir un programme qui marche et respecte les <a href="#packaging">contraintes</a></li>
        <li>Faire tourner notre jeu de règle témoin en donnant le bon score</li>
        <li>Un programme par personne</li>
        <li>Pas de programme en doublon</li>
        <li>Nous autoriser à publier votre solution ici en cas de victoire</li>
        <li>Envoyer vos réponses à <a href="mailto:&#099;&#111;&#110;&#116;&#101;&#115;&#116;&#064;&#100;&#105;&#109;&#101;&#108;&#111;&#046;&#099;&#111;&#109;?subject=Solution Christmas Contest">contest at dimelo.com</a></li>
        <li>Rendre sa solution avant le 10 janvier 2012 à midi, les résultats seront communiqués lors du premier <a href="http://www.meetup.com/parisrb/">événement Paris.rb de 2012</a></li>
        <li>Si plusieurs programmes répondent à ces différents points, le gagnant sera tiré au sort parmi ceux-là</li>
      </ul>
    </div>
  </div><!-- /row -->
</section>
<section id="contest">
  <div class="page-header">
    <h1>Le défi en détail</h1>
  </div>
  <div class="row">
    <div class="span4">
      <h2>Les données de départs</h2>
      <p>Le programme démarrera avec ces données constantes correspondant à un sous-ensemble de données d'un profil github (celui de Defunkt). C'est sur ces données que devront s'appliquer les règles et l'execution des règles fournira un score utilisateur. Il n'y a donc rien de spécial à faire au niveau programmation, juste à utiliser le profil test ci-dessous.</p>
    </div>
    <div class="span12">
      <h3>Les données du profil</h3>
      <p>Les données du hash correspondent à un profil github, voici le détail des clés :</p>
      <table class="bordered-table zebra-striped">
        <thead>
          <tr>
            <th>Clé</th>
            <th>Type</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>login</code></td>
            <td>String</td>
            <td>Nom du profil (pour info)</td>
          </tr>
          <tr>
            <td><code>followers</code></td>
            <td>Fixnum</td>
            <td>Nombre de followers du profil</td>
          </tr>
          <tr>
            <td><code>commits</code></td>
            <td>Fixnum</td>
            <td>Nombre de commits effectués par le profil</td>
          </tr>
          <tr>
            <td><code>repositories</code></td>
            <td>Array</td>
            <td>Tableau de project ayant chacun un <code>name</code> de type string (pour info) et 2 attributs de type Fixnum <code>watchers</code> et <code>forks</code></td>
          </tr>
        </tbody>
      </table>
      <h3>Données du profil</h3>
      <p>Voilà la constante de profil sur laquelle seront appliquée les règles, la seule partie dynamique du programme sera donc de lire, parser et executer le fichier de règles. Le reste (comme ici le profil) est statique</p>
      <pre class="prettyprint">

      {
        "login" => "defunkt",
        "followers" => 4674,
        "commits" => 8901,
        "repositories" => [
                            {
                              "watchers" => 79,
                              "forks" => 9,
                              "name" => "choice"
                            },
                            {
                              "watchers" => 28,
                              "forks" => 1,
                              "name" => "mapreducerb"
                            },
                            {
                              "watchers" => 16,
                              "forks" => 3,
                              "name" => "ambitious_activerecord"
                            },
                            {
                              "watchers" => 151,
                              "forks" => 39,
                              "name" => "emacs"
                            },
                            {
                              "watchers" => 787,
                              "forks" => 116,
                              "name" => "github-gem"
                            },
                            {
                              "watchers" => 1559,
                              "forks" => 298,
                              "name" => "facebox"
                            },
                            {
                              "watchers" => 2977,
                              "forks" => 425,
                              "name" => "resque"
                            } 
                          ]
      }
      </pre>
    </div>
  </div>

  <div class="row">
    <div class="span4">
      <h2>Le moteur de règle</h2>
      <p>On attaque le coeur du défi et la partie à réaliser, c'est à dire le parser de règle et l'exécuteur des règles sur les données. Les règles sont de simples instructions dans un fichier texte dont la syntaxe est précisée ci-dessous et qui s'appliquent aux attributs du profil <code>followers</code>, <code>commits</code> et <code>repositories</code>. Ces règles précisent le nombre de point à attribuer pour chaque attribut du profil. Pour corser le problème, au niveau des repositories les règles peuvent être conditionnées sur les valeurs des attributs du repository (le nombre de forks et de watchers). Et finalement ces règles ne sont pas forcement mutuellement exclusives sur le principe de la dernière règle qui s'applique écrase les autres, elles peuvent être additives si l'opérateur adéquat est utilisé. Toute règle non définie sur un attribut du profil est à 0 (pas de point attribués par défaut). Commençons donc par quelques exemples.</p>
    </div>
    <div class="span12">
      <h3>Cas simple</h3>
      <p>Le fichier contient une règle simple pour chacun des attributs, en l'occurrence 1 point par follower, 1 point par commit et 1 point par repository</p>
      <pre class="prettyprint">

        commit = 1
        repository = 1
        follower = 1

      </pre>
      <p><strong>Résultat:</strong> En l'occurrence le score de l'utilisateur sera donc égal à followers + repositories.size + commits. </p>

      <h3>Cas conditionnel</h3>
      <p>Les conditions ne concernent que les attributs de repository et donc que les points attribués aux repositories. Les opérateur de comparaison à supporter sont <code>&gt;</code> et <code>&lt;</code> qui ont le même sens qu'en ruby. L'opérateur s'applique avec à gauche un attribut de repository et à droite un entier. On peut combiner les conditions juste avec l'opérateur <code>&amp;&amp;</code> qui correspond à l'opérateur logique AND. Les conditions sont executées au runtime avant les affectations (comme en ruby), si la condition est fausse l'affectation est ignorées. Quand plusieurs affectation par l'opérateur <code>=</code> sont executées successivement, seule la dernière affectation est conservée (comme pour l'affectation de variable). La logique d'execution des règles est ici similaire à du code ruby.</p>
      <pre class="prettyprint">
    
        repository = 1
        repository = 5 if repository.watchers &gt; 10
        repository = 5 if repository.forks &gt; 10
        repository = 20 if repository.watchers &gt; 10 &amp;&amp; repository.forks &gt; 10

      </pre>

    <p><strong>Résultat:</strong> Dans ce cas les commits et les followers ne rapportent pas de point (à 0 par défaut) et chaque repository rapporte 1 point s'il a moins de 11 watchers et forks, 5 points s'il a plus de 10 watchers OU plus de 10 forks et 20 points s'il a plus de 10 watchers ET plus de 10 forks.</p>

     <h3>Cas d'additivité</h3>
     <p> Jusque-là chaque définition d'attribution de points écrasait la précédente à partir du moment où elle s'executait (les conditions, si il y en avait, étaient remplies). Il existe un autre opérateur d'affection <code>+=</code> qui permet d'ajouter des points à l'affectation existante plutôt que de la remplacer. Cela fonctionne comme l'opérateur += en ruby. </p>

      <pre class="prettyprint">

        commit = 1
        commit = 2
        commit += 3
        follower = 1
        follower += 2
        follower = 5
        repository += 5

      </pre>

      <p> <strong>Résultat:</strong> Ici on est dans le cas où on attribue 5 points par commit, par follower et par repository. L'arythmétique en jeu est identique à de l'affectation de variable en ruby, l'affectation remplace la valeur précédente et l'affectation additive affecte au registre la valeur "ancienne valeur + nouvelle valeur". Le seul cas un peu spécial ici est le cas de repository qui affecte 5 à la valeur par defaut (zéro), ce qui donne donc 5 au final.</p>

      <h3>Cas complet</h3>

      <p> Exemple d'un cas avec les opérateurs d'affectation et les conditions en même temps. </p>

      <pre class="prettyprint">

        follower = 2
        repository = 5
        repository = 1 if repository.watchers  &lt; 2 &amp;&amp; repository.forks &lt; 2
        repository += 10 if repository.watchers  &gt; 10
        repository += 10 if repository.forks  &gt;  10
        repository = 50 if repository.watchers  &gt; 100 &amp;&amp; repository.forks &gt; 100

      </pre>
      <p>
        <strong>Résultat:</strong> C'est le cas le plus complet que l'on puisse avoir, les commits rapportent 0, les followers rapportent 2 points, et au niveau des repositories ceux qui ont moins de 2 watchers ET forks rapportent 1 points sinon la valeur de base est 5 point. Si en plus le repository a plus de 10 watchers on gagne un bonus de 10 points, pareil pour les forks. Si en plus à la fois les watchers et les forks dépassent 100 alors le reposity rapporte 50 points en tout.
      </p>
      <h3>Récapitulatif des opérateurs et opérandes</h3>
      
      <table class="bordered-table zebra-striped">
        <thead>
          <tr>
            <th>Object</th>
            <th>type</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code>repository</code> , <code>follower</code> , <code>commit</code></td>
            <td>Registre de point</td>
            <td>Ces registres définisse la valeur en point de l'object courant</td>
          </tr>
          <tr>
            <td><code>=</code> , <code>+=</code></td>
            <td>Operateur d'affectation</td>
            <td>Réaffecte ou affecte additivement un entier à un registre</td>
          </tr>
          <tr>
            <td><code>\d+</code></td>
            <td>Fixnum</td>
            <td>Valeur constante pouvant être affectée à un registre ou comparée à un attribut</td>
          </tr>
          <tr>
            <td><code>repository.watchers</code> , <code>repository.forks</code></td>
            <td>Attribut de l'object repository courant (s'il y en a)</td>
            <td>Ces attributs ont une valeur courante qui est un entier et peuvent être comparé à des Fixnum</td>
          </tr>
          <tr>
            <td><code>&gt;</code> , <code>&lt;</code></td>
            <td>Opérateur de comparaison</td>
            <td>Compare un attribut de l'object repository à un entier (le résultat de l'opération vaut vrai ou faux)</td>
          </tr>
          <tr>
            <td><code>&amp;&amp;</code></td>
            <td>Opérateur de logique AND</td>
            <td>Permet de combiner des opérations de comparaison</td>
          </tr>
          <tr>
            <td><code>if</code></td>
            <td>Opérateur conditionel</td>
            <td>Execute la règle si et seulement si la condition est vraie, sinon la règle est ignorée</td>
          </tr>
        </tbody>
      </table>
    </div>
  </div>

  <div class="row" id="packaging">
    <div class="span4">
      <h2>Packaging de la solution</h2>
    </div>
    <div class="span12">
      <h3>Packaging de la solution</h3>

      <p>La solution devra être un executable ruby, avec le shebang <code>#!/usr/bin/env ruby</code>, si il y a des Gem dont vous dépendez elles devront être gérée avec un Gemfile et le code devra tourner sur 1.8.7 MRI ou 1.9.3 MRI (.rvmrc à fournir dans ce cas là). Aucune autre dépendance que des gems, les libs de developments ruby et un compilateur C ne sont acceptées.</p>
      <p>L'executable ne prendra qu'un seul paramètre le chemin absolu du fichier de règle et devra en STDOUT renvoyer la valeur du score. Exemple:</p>
      <pre class="prettyprint">

        $ ./ruby-contest ./test-rules.txt
        1250

      </pre>
      <p>Les choix d'implémentation de la solution sont libres, DSL ruby, parser/lexer, peg/leg, regexp, à la mano, toutes les solutions sont acceptables même si certaines sont plus élégantes et extensibles que d'autres. Le gagnant officiel sera déterminé via <a href="#rules">les règles</a>.</p>
    </div>
  </div>
</section>
